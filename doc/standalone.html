<html>
<head>
<title>TableFilter - standalone editors mode</title>
</head>
<body><div id='content'>

  <h1>Standalone editors</h1>

    <p>
      Although the <a href='TableFilterHeader.hmtl'>TableFilterHeader</a> is 
      the compact way to use the 
      <a href='FilterEditors.hmtl'>filter editors</a>, it is obviously 
      possible to handle them on their own.
    </p>

    <p>
      All the filter editors implement the 
      <a href='api/net/coderazzi/filters/gui/ITableFilterEditor.html'>ITableFilterEditor</a>
      interface, so they can provide 
      <a href='api/net/coderazzi/filters/IFilterObservable.html'>IFilterObservable</a> 
      instances. Attaching a 
      <a href='api/net/coderazzi/filters/IFilterObserver.html'>IFilterObserver</a> 
      to it, it is possible to obtain the filter provided by that editor.
    </p>

    <p>
      The <a href='api/net/coderazzi/filters/TableFilter.html'>TableFilter</a> 
      class can simplify this process; it supports the adding of one or more 
      filter editors, and it is intended to be associated to a table. When the 
      user modifies those editors, the resulting filter is automatically 
      propagated to the table.
    </p>

    <p>
      All the filter editors included in the 
      <span class='mark'>TableFilter</span> are <b>and</b>-composed. That is, 
      the table will filter out all the rows that do not match <i>all</i> the 
      filter expressions. It behaves, therefore, as the 
      <span class='mark'>TableFilterHeader</span>, where the rows must verify 
      the filters setup for <i>each</i> column. In fact, the 
      <span class='mark'>TableFilterHeader</span> contains internally a 
      <span class='mark'>TableFilter</span>, but this relationship is not 
      visible to the user.
    </p>

    <p>
      However, it is possible to link the filter editors in 
      different compositions. The classes
      <a href='api/net/coderazzi/filters/AndFilter.html'>AndFilter</a>,
      <a href='api/net/coderazzi/filters/OrFilter.html'>OrFilter</a> and 
      <a href='api/net/coderazzi/filters/NotFilter.html'>NotFilter</a> 
      permit creating different logical results. The
      <span class='mark'>TableFilter</span>, is, in fact, an specialization 
      of the AndFilter.
    </p>
     
    <p>
      The source distribution of this library contains a test program that shows this standalone
      usage of editors (AppTestWithSeparateComponents.java), with a Gui like: 
    </p>  

    <p><img src="images/examplest.png" class="centered"></p>

    <p>
      In this example, there are three different filter editors. From top to bottom, a 
      <a href='editors.html#TextChoiceFilterEditor'>TextChoiceFilterEditor</a>, a
      <a href='editors.html#TextFilterEditor'>TextFilterEditor</a>, and a
      <a href='editors.html#ChoiceFilterEditor'>ChoiceFilterEditor</a>, 
      composing the final filter expression:
      (age &lt 20) OR ( ( Age &gt 35) AND NOT (male = false)) 
    </p>

    <p>
      The code required to setup this scenario is, not including the creation of the filter editors:
    </p>
    
<pre>TableFilter tableFilter = new TableFilter();
tableFilter.setTable(table);        
tableFilter.addFilterObservable(
  new OrFilter(topFilter.getFilterObservable(),
    new AndFilter(
      middleFilter.getFilterObservable(),
      new NotFilter(bottomFilter.getFilterObservable()))));</pre>		

    <p>
      Using the editors in this way implies that the programmer must take 
      care of all the details concerning the editors initialization and 
      their updates if the table changes. In special:
      <ul>
        <li>In case of parsing editors, it is needed to create and associate a 
          <a href='api/net/coderazzi/filters/parser/IFilterTextParser.html'>IFilterTextParser</a> 
          instance.</li>
        <li>In case that the table's structure can change, any update should 
          be propagated to the editors and to the used parser.</li>
      </ul>
    </p>

    <p>
      The initialization of editors and the 
      <a href='api/net/coderazzi/filters/parser/IFilterTextParser.html'>IFilterTextParser</a>
      requires the handling two concepts:
      <ul>
        <li><b>Identifiers</b>: these are the <i>variables</i> handled by the 
          parser. Each identifier has a name, a type, and a filter position.</li>
        <li><b>Filter position</b>: A filter supporting the interface 
          <a href='http://java.sun.com/javase/6/docs/api/javax/swing/RowFilter.html?is-external=true'>RowFilter</a> 
          receives an instance of type 
          <a href='http://java.sun.com/javase/6/docs/api/javax/swing/RowFilter.Entry.html?is-external=true'>RowFilter.Entry</a> 
          that it can enquiry to obtain  the value at a specified index; the 
          filter position is that given index, and corresponds, in the case of 
          a table, to the column to which this editor is associated.</li>
      </ul>
    </p>

    <p>
      The helper class 
      <a href='api/net/coderazzi/filters/parser/generic/TableFilterHelper.html'>TableFilterHelper</a> 
      can be used to create the identifiers of a table, or to create directly
      a parser already initialized. It reads the headers of the table, and 
      their associated types, to extract the table's identifiers, in the same 
      way that the <span class='mark'>TableFilterHeader</span> does:
    </p>

    <pre>FilterTextParser parser = TableFilterHelper.createTextFilterParser(tableModel);
topFilter.setTextParser(parser);
middleFilter.setTextParser(parser);</pre>
    
</div></body>
</html>